{
  "slug": "implement-binary-search",
  "title": "Implement Binary Search",
  "c": "#include <stdio.h>\n\nint binarySearch(int ARay[], int thing, int findThis) \n{\n    int lowerBound = 0;\n    int upperBound = thing - 1;\n\n    while (lowerBound <= upperBound) \n    {\n        int mid = lowerBound + (upperBound - lowerBound) / 2;\n\n        if (ARay[mid] == findThis) \n        {\n            return mid;\n        }\n        else if (ARay[mid] < findThis) \n        {\n            lowerBound = mid + 1;\n        }\n        else \n        {\n            upperBound = mid - 1;\n        }\n    }\n    return -1;\n}\n\nint main() \n{\n    int ARay[] = { 1, 2, 3, 4, 5 };\n    int thing = sizeof(ARay) / sizeof(ARay[0]);\n    int findThis = 4;\n\n    int neededThing = binarySearch(ARay, thing, findThis);\n\n    if (neededThing != -1) \n    {\n        printf(\"Element found! It is located at index %d\\n\", neededThing);\n    }\n    else \n    {\n        printf(\"ERROR! The given element does not exist in the current array :(\\n\");\n    }\n    return 0;\n}\n\n/* Cautiously Crafted By Redzwinger */",
  "c-plus-plus": "#include <bits/stdc++.h>\nusing namespace std;\n\nint binarySearch(int arr[], int size, int key) {\n  int low = 0;\n  int high = size - 1;\n  while (low <= high) {\n    int mid = low + (high - low) / 2;\n    if (arr[mid] == key) {\n      return mid;\n    } else if (arr[mid] < key) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int size;\n  cout << \"Enter the size of the array: \";\n  cin >> size;\n  int arr[size];\n  cout << \"Enter the elements of the array in sorted order:\\n\";\n  for (int i = 0; i < size; ++i) {\n    cout << \"Enter element \" << (i + 1) << \": \";\n    cin >> arr[i];\n  }\n  int key;\n  cout << \"Enter the key to search: \";\n  cin >> key;\n  int result = binarySearch(arr, size, key);\n  if (result != -1) {\n    cout << \"Element found at index: \" << result << endl;\n  } else {\n    cout << \"Element not found in the array.\" << endl;\n  }\n  return 0;\n}\n",
  "java": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class ImplementBinarySearch {\n\n    public static int binarysearch(int arr[],int value){\n\n        int low = 0;\n        int high = arr.length - 1;\n        \n        while(low <= high){\n            int mid = (low+high)/2;\n\n            if(arr[mid] == value){\n                return mid;\n            }\n           else if(value < arr[mid]){\n                high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n\n        }\n        return -1;\n    }\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"Enter the size of the array:\");\n        int size = scanner.nextInt();\n\n        int[] inputArray = new int[size];\n\n        System.out.println(\"Enter the elements of the array:\");\n        for(int i=0;i<size;i++){\n            inputArray[i] = scanner.nextInt();\n        }\n\n        Arrays.sort(inputArray);\n\n        System.out.println(\"Enter the value to search:\");\n       \n        int searchValue = scanner.nextInt();\n\n        int result = binarysearch(inputArray, searchValue);\n\n        if(result != -1){\n            System.out.println(\"Element found at index: \" + result);\n        }\n        else{\n            System.out.println(\"Element not found in the array.\");\n        }\n\n        scanner.close();\n\n\n    }   \n\n}\n",
  "description": "\n## Write a program to implement binary search\n\nBinary search is a fast search algorithm with run-time complexity of Ο(log n). This search algorithm works on the principle of divide and conquer. For this algorithm to work properly, the data collection should be in the sorted form.\r\n\r\nBinary search looks for a particular item by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero.\r\n\r\n### Pseudocode\r\n\r\n```text\r\nprocedure binary_search\r\n   A ← sorted array\r\n   n ← size of array\r\n   x ← value to be searched\r\n\r\n   Set lowerBound = 1\r\n   Set upperBound = n\r\n\r\n   while x not found\r\n      if upperBound < lowerBound\r\n         EXIT: x does not exists.\r\n   \r\n      set midPoint = lowerBound + ( upperBound - lowerBound ) / 2\r\n      \r\n      if A[midPoint] < x\r\n         set lowerBound = midPoint + 1\r\n         \r\n      if A[midPoint] > x\r\n         set upperBound = midPoint - 1 \r\n\r\n      if A[midPoint] = x \r\n         EXIT: x found at location midPoint\r\n   end while\r\n   \r\nend procedure\r\n```\r\n\r\n### Example\r\n\r\n```text\r\nlist = [1,2,3,4,5]\r\nvalue = 4\r\n\r\nOutput : 3\r\n```\n\n---\n",
  "trackId": 5192,
  "lastUpdated": "2024-01-15T18:24:13Z",
  "contributors": [
    "Redzwinger",
    "prathebaAT",
    "amananand20",
    "Shivamk034",
    "Amedi-Imbira",
    "harshraj8843"
  ],
  "dart": "int binarySearch(List<int> arr, int x) {\n  int lowerBound = 0;\n  int upperBound = arr.length - 1;\n\n  while (lowerBound <= upperBound) {\n    int midPoint = (lowerBound + upperBound) ~/ 2;\n\n    if (arr[midPoint] == x) {\n      return midPoint;                //Element found return it's index\n    } else if (arr[midPoint] < x) {\n      lowerBound = midPoint + 1;      //Search in the right half\n    } else {\n      upperBound = midPoint - 1;      //Search in the left half\n    }\n  }\n  return -1;\n}\n\nvoid main() {\n  //Example Usage\n  List<int> sortedArray = [1, 2, 3, 4, 5];\n  int valueToSearch = 4;\n\n  int resultIndex = binarySearch(sortedArray, valueToSearch);\n\n  if (resultIndex != -1) {\n    print('Elemenet $valueToSearch found at index $resultIndex');\n  } else {\n    print('Element $valueToSearch not found in the array');\n  }\n}\n",
  "python": "def main():\n      seq = 1, 2, 3, 4, 5, 6, 7           # Test here. Seq should be sorted\n      print(binary_search(seq, 90))\n\ndef binary_search(data, target):\n      \"\"\" \n            locating a target value within a sorted sequence\n            return True if target is found\n      \"\"\"\n      left = 0\n      right = len(data)-1\n      \n      while left <= right:\n            mid = (left + right) // 2\n            if target == data[mid]:                   # Found match!\n                  return True\n            elif target < data[mid]:                  # Search values left of mid\n                  right = mid-1\n            else:                                     # Search values right of mid\n                  left = mid+1 \n      return False                                    # loop ended without success\n\nif __name__ == '__main__':\n      main()",
  "rust": "use std::io;\n\nfn binary_search(arr: &[i32], key: i32) -> Option<usize> {\n  let mut low = 0;\n  let mut high = arr.len() - 1;\n\n  while low <= high {\n    let mid = low + (high - low) / 2;\n\n    if arr[mid] == key {\n      return Some(mid);\n    } else if arr[mid] < key {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  None\n}\n\nfn main() {\n  let size: usize = read_input();\n  let mut arr = read_array(size);\n  let key: i32 = read_input();\n\n  match binary_search(&arr, key) {\n    Some(result) => println!(\"Element found at index: {}\", result),\n    None => println!(\"Element not found in the array.\"),\n  }\n}\n\nfn read_input<T>() -> T\nwhere\n  T: std::str::FromStr,\n  T::Err: std::fmt::Debug,\n{\n  let mut input = String::new();\n  io::stdin().read_line(&mut input).expect(\"Failed to read input\");\n  input.trim().parse().expect(\"Invalid input\")\n}\n\nfn read_array(size: usize) -> Vec<i32> {\n  (0..size)\n    .map(|_| read_input())\n    .collect()\n}\n",
  "languages": [
    "c",
    "c-plus-plus",
    "java",
    "dart",
    "python",
    "rust"
  ]
}